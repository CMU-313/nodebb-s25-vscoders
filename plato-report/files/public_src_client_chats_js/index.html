<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - public/src/client/chats.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>public/src/client/chats.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.47</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">841</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">62.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.24</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;


define(&#039;forum/chats&#039;, [
	&#039;components&#039;,
	&#039;mousetrap&#039;,
	&#039;forum/chats/recent&#039;,
	&#039;forum/chats/create&#039;,
	&#039;forum/chats/manage&#039;,
	&#039;forum/chats/messages&#039;,
	&#039;forum/chats/user-list&#039;,
	&#039;forum/chats/message-search&#039;,
	&#039;forum/chats/pinned-messages&#039;,
	&#039;composer/autocomplete&#039;,
	&#039;hooks&#039;,
	&#039;bootbox&#039;,
	&#039;alerts&#039;,
	&#039;chat&#039;,
	&#039;api&#039;,
	&#039;uploadHelpers&#039;,
], function (
	components, mousetrap, recentChats, create,
	manage, messages, userList, messageSearch, pinnedMessages,
	autocomplete, hooks, bootbox, alerts, chatModule, api,
	uploadHelpers
) {
	const Chats = {
		initialised: false,
		activeAutocomplete: {},
	};

	let newMessage = false;
	let chatNavWrapper = null;

	$(window).on(&#039;action:ajaxify.start&#039;, function () {
		Chats.destroyAutoComplete(ajaxify.data.roomId);
		if (ajaxify.data.template.chats) {
			if (ajaxify.data.roomId) {
				socket.emit(&#039;modules.chats.leave&#039;, ajaxify.data.roomId);
			}
			if (ajaxify.data.publicRooms) {
				socket.emit(&#039;modules.chats.leavePublic&#039;, ajaxify.data.publicRooms.map(r =&gt; r.roomId));
			}
		}
	});

	Chats.init = function () {
		if (!utils.isMobile()) {
			$(&#039;.chats-full [data-bs-toggle=&quot;tooltip&quot;]&#039;).tooltip({
				trigger: &#039;hover&#039;,
				container: &#039;#content&#039;,
			});
		}
		socket.emit(&#039;modules.chats.enterPublic&#039;, ajaxify.data.publicRooms.map(r =&gt; r.roomId));
		const env = utils.findBootstrapEnvironment();
		chatNavWrapper = $(&#039;[component=&quot;chat/nav-wrapper&quot;]&#039;);
		if (!Chats.initialised) {
			Chats.addSocketListeners();
			Chats.addGlobalEventListeners();
		}

		recentChats.init();

		Chats.addEventListeners();
		Chats.setActive(ajaxify.data.roomId);

		if (env === &#039;md&#039; || env === &#039;lg&#039; || env === &#039;xl&#039; || env === &#039;xxl&#039;) {
			Chats.addHotkeys();
		}

		Chats.initialised = true;
		const chatContentEl = $(&#039;[component=&quot;chat/message/content&quot;]&#039;);
		messages.wrapImagesInLinks(chatContentEl);
		if (ajaxify.data.scrollToIndex) {
			messages.toggleScrollUpAlert(chatContentEl);
			const scrollToEl = chatContentEl.find(`[data-index=&quot;${ajaxify.data.scrollToIndex - 1}&quot;]`);
			if (scrollToEl.length) {
				chatContentEl.scrollTop(
					chatContentEl.scrollTop() - chatContentEl.offset().top + scrollToEl.offset().top
				);
			}
		} else {
			messages.scrollToBottomAfterImageLoad(chatContentEl);
		}
		create.init();

		hooks.fire(&#039;action:chat.loaded&#039;, $(&#039;.chats-full&#039;));
	};

	Chats.addEventListeners = function () {
		const { roomId } = ajaxify.data;
		const mainWrapper = $(&#039;[component=&quot;chat/main-wrapper&quot;]&#039;);
		const chatMessageContent = $(&#039;[component=&quot;chat/message/content&quot;]&#039;);
		const chatControls = components.get(&#039;chat/controls&#039;);
		Chats.addSendHandlers(roomId, $(&#039;.chat-input&#039;), $(&#039;.expanded-chat button[data-action=&quot;send&quot;]&#039;));
		Chats.addPopoutHandler();
		Chats.addActionHandlers(components.get(&#039;chat/message/window&#039;), roomId);
		Chats.addManageHandler(roomId, chatControls.find(&#039;[data-action=&quot;manage&quot;]&#039;));
		Chats.addRenameHandler(roomId, chatControls.find(&#039;[data-action=&quot;rename&quot;]&#039;));
		Chats.addLeaveHandler(roomId, chatControls.find(&#039;[data-action=&quot;leave&quot;]&#039;));
		Chats.addDeleteHandler(roomId, chatControls.find(&#039;[data-action=&quot;delete&quot;]&#039;));
		Chats.addScrollHandler(roomId, ajaxify.data.uid, chatMessageContent);
		Chats.addScrollBottomHandler(roomId, chatMessageContent);
		Chats.addParentHandler(mainWrapper);
		Chats.addCharactersLeftHandler(mainWrapper);
		Chats.addTextareaResizeHandler(mainWrapper);
		Chats.addTypingHandler(mainWrapper, roomId);
		Chats.addIPHandler(mainWrapper);
		Chats.addCopyTextLinkHandler(mainWrapper);
		Chats.createAutoComplete(roomId, $(&#039;[component=&quot;chat/input&quot;]&#039;));
		Chats.addUploadHandler({
			dragDropAreaEl: $(&#039;.chats-full&#039;),
			pasteEl: $(&#039;[component=&quot;chat/input&quot;]&#039;),
			uploadFormEl: $(&#039;[component=&quot;chat/upload&quot;]&#039;),
			uploadBtnEl: $(&#039;[component=&quot;chat/upload/button&quot;]&#039;),
			inputEl: $(&#039;[component=&quot;chat/input&quot;]&#039;),
		});

		$(&#039;[data-action=&quot;close&quot;]&#039;).on(&#039;click&#039;, function () {
			Chats.switchChat();
		});
		userList.init(roomId, mainWrapper);
		Chats.addNotificationSettingHandler(roomId, mainWrapper);
		messageSearch.init(roomId, mainWrapper);
		Chats.addPublicRoomSortHandler();
		Chats.addTooltipHandler(mainWrapper);
		pinnedMessages.init(mainWrapper);
	};

	Chats.addPublicRoomSortHandler = function () {
		if (app.user.isAdmin &amp;&amp; !utils.isMobile()) {
			app.loadJQueryUI(() =&gt; {
				const publicRoomList = $(&#039;[component=&quot;chat/public&quot;]&#039;);
				publicRoomList.sortable({
					handle: &#039;[component=&quot;chat/public/room/sort/handle&quot;]&#039;,
					items: &#039;[component=&quot;chat/public/room&quot;]&#039;,
					axis: &#039;y&#039;,
					update: async function () {
						const data = { roomIds: [], scores: [] };
						publicRoomList.find(&#039;[data-roomid]&#039;).each((idx, el) =&gt; {
							data.roomIds.push($(el).attr(&#039;data-roomid&#039;));
							data.scores.push(idx);
						});
						await api.put(&#039;/chats/sort&#039;, data);
					},
				});
			});
		}
	};

	Chats.addTooltipHandler = function (containerEl) {
		if (utils.isMobile()) {
			return;
		}

		containerEl.find(&#039;[data-manual-tooltip]&#039;).tooltip({
			trigger: &#039;manual&#039;,
			animation: false,
			placement: &#039;bottom&#039;,
		}).on(&#039;mouseenter&#039;, function (ev) {
			const target = $(ev.target);
			const isDropdown = target.hasClass(&#039;dropdown-menu&#039;) || !!target.parents(&#039;.dropdown-menu&#039;).length;
			if (!isDropdown) {
				$(this).tooltip(&#039;show&#039;);
			}
		}).on(&#039;click mouseleave&#039;, function () {
			$(this).tooltip(&#039;hide&#039;);
		});

		containerEl.tooltip({
			selector: &#039;[component=&quot;chat/message/controls&quot;] &gt; .btn-group &gt; button&#039;,
			placement: &#039;top&#039;,
			container: &#039;#content&#039;,
			animation: false,
			trigger: &#039;hover&#039;,
		});
	};

	Chats.addNotificationSettingHandler = function (roomId, containerEl) {
		const notifSettingEl = containerEl.find(&#039;[component=&quot;chat/notification/setting&quot;]&#039;);

		notifSettingEl.find(&#039;[data-value]&#039;).on(&#039;click&#039;, async function () {
			notifSettingEl.find(&#039;i.fa-check&#039;).addClass(&#039;hidden&#039;);
			const $this = $(this);
			$this.find(&#039;i.fa-check&#039;).removeClass(&#039;hidden&#039;);
			notifSettingEl.find(&#039;[component=&quot;chat/notification/setting/icon&quot;]&#039;).attr(&#039;class&#039;, `fa ${$this.attr(&#039;data-icon&#039;)}`);
			await api.put(`/chats/${roomId}/watch`, {
				value: $this.attr(&#039;data-value&#039;),
			});
		});
	};

	Chats.addParentHandler = function (mainWrapper) {
		mainWrapper.off(&#039;click&#039;, &#039;[component=&quot;chat/message/parent&quot;]&#039;)
			.on(&#039;click&#039;, &#039;[component=&quot;chat/message/parent&quot;]&#039;, function () {
				const parentEl = $(this);
				parentEl.find(&#039;[component=&quot;chat/message/parent/content&quot;]&#039;).toggleClass(&#039;line-clamp-1&#039;);
				parentEl.find(&#039;.chat-timestamp&#039;).toggleClass(&#039;hidden&#039;);
				parentEl.toggleClass(&#039;flex-column&#039;).toggleClass(&#039;flex-row&#039;);
				const chatContent = parentEl.parents(&#039;[component=&quot;chat/message/content&quot;]&#039;);
				if (chatContent.length &amp;&amp; messages.isAtBottom(chatContent)) {
					messages.scrollToBottom(chatContent);
				}
			});
	};


	Chats.addUploadHandler = function (options) {
		uploadHelpers.init({
			dragDropAreaEl: options.dragDropAreaEl,
			pasteEl: options.pasteEl,
			uploadFormEl: options.uploadFormEl,
			uploadBtnEl: options.uploadBtnEl,
			route: &#039;/api/post/upload&#039;, // using same route as post uploads
			callback: function (uploads) {
				const inputEl = options.inputEl;
				let text = inputEl.val();
				uploads.forEach((upload) =&gt; {
					text = text + (!text.endsWith(&#039;\n&#039;) ? &#039;\n&#039; : &#039;&#039;) + (upload.isImage ? &#039;!&#039; : &#039;&#039;) + `[${upload.filename}](${upload.url})\n`;
				});
				inputEl.val(text).trigger(&#039;input&#039;);
			},
		});
	};

	Chats.addIPHandler = function (container) {
		container.off(&#039;click&#039;, &#039;.chat-ip-button&#039;)
			.on(&#039;click&#039;, &#039;.chat-ip-button&#039;, async function (ev) {
				ev.stopPropagation();
				const ipEl = $(this);
				const ipCopyText = ipEl.find(&#039;.copy .copy-ip-text&#039;);
				let ip = ipEl.attr(&#039;data-ip&#039;);
				if (ip) {
					navigator.clipboard.writeText(ip);
					ipCopyText.translateText(&#039;[[global:copied]]&#039;);
					setTimeout(() =&gt; ipCopyText.text(ip), 2000);
					return;
				}
				const mid = ipEl.parents(&#039;[data-mid]&#039;).attr(&#039;data-mid&#039;);
				({ ip } = await api.get(`/chats/${ajaxify.data.roomId}/messages/${mid}/ip`));
				ipEl.attr(&#039;data-ip&#039;, ip);
				ipEl.find(&#039;.show&#039;).addClass(&#039;hidden&#039;);
				ipEl.find(&#039;.copy&#039;).removeClass(&#039;hidden&#039;);
				ipCopyText.text(ip);
			});
	};

	Chats.addCopyTextLinkHandler = function (container) {
		function doCopy(copyEl, text) {
			navigator.clipboard.writeText(text);
			copyEl.find(&#039;i&#039;).addClass(&#039;fa-check&#039;).removeClass(&#039;fa-link&#039;);
			setTimeout(() =&gt; copyEl.find(&#039;i&#039;).removeClass(&#039;fa-check&#039;).addClass(&#039;fa-link&#039;), 2000);
		}

		container.off(&#039;click&#039;, &#039;[data-action=&quot;copy-link&quot;]&#039;)
			.on(&#039;click&#039;, &#039;[data-action=&quot;copy-link&quot;]&#039;, function (ev) {
				ev.stopPropagation();
				const copyEl = $(this);
				const mid = copyEl.attr(&#039;data-mid&#039;);
				if (mid) {
					doCopy(copyEl, `${window.location.origin}/message/${mid}`);
				}
			});

		container.off(&#039;click&#039;, &#039;[data-action=&quot;copy-text&quot;]&#039;)
			.on(&#039;click&#039;, &#039;[data-action=&quot;copy-text&quot;]&#039;, function (ev) {
				ev.stopPropagation();
				const copyEl = $(this);
				const messageEl = copyEl.parents(&#039;[data-mid]&#039;);
				if (messageEl.length) {
					doCopy(copyEl, messageEl.find(&#039;[component=&quot;chat/message/body&quot;]&#039;).text().trim());
				}
			});
	};

	Chats.addPopoutHandler = function () {
		$(&#039;[data-action=&quot;pop-out&quot;]&#039;).on(&#039;click&#039;, function () {
			const text = components.get(&#039;chat/input&#039;).val();
			const roomId = ajaxify.data.roomId;

			if (app.previousUrl &amp;&amp; app.previousUrl.match(/chats/)) {
				ajaxify.go(&#039;user/&#039; + ajaxify.data.userslug + &#039;/chats&#039;, function () {
					chatModule.openChat(roomId, ajaxify.data.uid);
				}, true);
			} else {
				window.history.go(-1);
				chatModule.openChat(roomId, ajaxify.data.uid);
			}

			$(window).one(&#039;action:chat.loaded&#039;, function () {
				components.get(&#039;chat/input&#039;).val(text);
			});
		});
	};

	Chats.addScrollHandler = function (roomId, uid, el) {
		let loading = false;
		let previousScrollTop = el.scrollTop();
		let currentScrollTop = previousScrollTop;
		el.off(&#039;scroll&#039;).on(&#039;scroll&#039;, utils.debounce(function () {
			if (parseInt(el.attr(&#039;data-ignore-next-scroll&#039;), 10) === 1) {
				el.removeAttr(&#039;data-ignore-next-scroll&#039;);
				previousScrollTop = el.scrollTop();
				return;
			}
			messages.toggleScrollUpAlert(el);
			if (loading) {
				return;
			}
			currentScrollTop = el.scrollTop();

			const direction = currentScrollTop &gt; previousScrollTop ? 1 : -1;
			previousScrollTop = currentScrollTop;
			const scrollPercent = 100 * (currentScrollTop / (el[0].scrollHeight - el.height()));
			const top = 15;
			const bottom = 85;

			if (direction === 1 &amp;&amp; !ajaxify.data.scrollToIndex) {
				// dont trigger infinitescroll if there is no /index in url
				return;
			}

			if ((scrollPercent &lt; top &amp;&amp; direction === -1) || (scrollPercent &gt; bottom &amp;&amp; direction === 1)) {
				loading = true;

				const msgEls = el.children(&#039;[data-mid]&#039;).not(&#039;.new&#039;);
				const afterEl = direction &gt; 0 ? msgEls.last() : msgEls.first();
				const start = parseInt(afterEl.attr(&#039;data-index&#039;), 10) || 0;

				api.get(`/chats/${roomId}/messages`, { uid, start, direction }).then((data) =&gt; {
					let messageData = data.messages;
					if (!messageData) {
						loading = false;
						return;
					}
					messageData = messageData.filter(function (chatMsg) {
						const msgOnDom = el.find(&#039;[component=&quot;chat/message&quot;][data-mid=&quot;&#039; + chatMsg.messageId + &#039;&quot;]&#039;);
						msgOnDom.removeClass(&#039;new&#039;);
						return !msgOnDom.length;
					});
					if (!messageData.length) {
						loading = false;
						return;
					}
					messages.parseMessage(messageData, function (html) {
						el.attr(&#039;data-ignore-next-scroll&#039;, 1);
						if (direction &gt; 0) {
							html.insertAfter(afterEl);
							messages.onMessagesAddedToDom(html);
						} else {
							const currentScrollTop = el.scrollTop();
							const previousHeight = el[0].scrollHeight;
							el.prepend(html);
							messages.onMessagesAddedToDom(html);
							el.scrollTop((el[0].scrollHeight - previousHeight) + currentScrollTop);
						}

						loading = false;
					});
				}).catch(alerts.error);
			}
		}, 100));
	};

	Chats.addScrollBottomHandler = function (roomId, chatContent) {
		chatContent.parents(&#039;[component=&quot;chat/message/window&quot;]&#039;)
			.find(&#039;[component=&quot;chat/messages/scroll-up-alert&quot;]&#039;)
			.off(&#039;click&#039;).on(&#039;click&#039;, function () {
				if (ajaxify.data.scrollToIndex &amp;&amp; parseInt(ajaxify.data.roomId, 10) === parseInt(roomId, 10)) {
					Chats.switchChat(roomId);
				} else {
					messages.scrollToBottom(chatContent);
				}
			});
	};

	Chats.addCharactersLeftHandler = function (parent) {
		const element = parent.find(&#039;[component=&quot;chat/input&quot;]&#039;);
		element.on(&#039;change keyup paste&#039;, function () {
			messages.updateRemainingLength(parent);
		});
	};

	Chats.addTextareaResizeHandler = function (parent) {
		// https://stackoverflow.com/questions/454202/creating-a-textarea-with-auto-resize
		const textarea = parent.find(&#039;[component=&quot;chat/input&quot;]&#039;);
		textarea.on(&#039;input&#039;, function () {
			const chatContentEl = parent.find(&#039;[component=&quot;chat/message/content&quot;]&#039;);
			const isAtBottom = messages.isAtBottom(chatContentEl);
			textarea.css({ height: 0 });
			textarea.css({ height: messages.calcAutoTextAreaHeight(textarea) + &#039;px&#039; });
			if (isAtBottom) {
				messages.scrollToBottom(chatContentEl);
			}
		});
	};

	Chats.addTypingHandler = function (parent, roomId) {
		const textarea = parent.find(&#039;[component=&quot;chat/input&quot;]&#039;);
		function emitTyping(typing) {
			api.put(`/chats/${roomId}/typing`, { typing }).catch(alerts.error);
		}

		textarea.on(&#039;focus&#039;, () =&gt; textarea.val() &amp;&amp; emitTyping(true));
		textarea.on(&#039;blur&#039;, () =&gt; emitTyping(false));
		let timeoutid = 0;
		let hasText = !!textarea.val();
		textarea.on(&#039;input&#039;, function () {
			const _hasText = !!textarea.val();
			if (_hasText !== hasText) {
				clearTimeout(timeoutid);
				timeoutid = 0;
				hasText = _hasText;
				emitTyping(hasText);
			} else if (!timeoutid) {
				timeoutid = setTimeout(() =&gt; {
					emitTyping(!!textarea.val());
					timeoutid = 0;
				}, 5000);
			}
		});
	};

	Chats.addActionHandlers = function (element, roomId) {
		element.on(&#039;click&#039;, &#039;[data-mid] [data-action]&#039;, function () {
			const msgEl = $(this).parents(&#039;[data-mid]&#039;);
			const messageId = msgEl.attr(&#039;data-mid&#039;);
			const action = this.getAttribute(&#039;data-action&#039;);
			$(this).tooltip(&#039;dispose&#039;);
			switch (action) {
				case &#039;reply&#039;:
					messages.prepReplyTo(msgEl, element);
					break;
				case &#039;edit&#039;:
					messages.prepEdit(msgEl, messageId, roomId);
					break;
				case &#039;delete&#039;:
					messages.delete(messageId, roomId);
					break;
				case &#039;restore&#039;:
					messages.restore(messageId, roomId);
					break;
				case &#039;pin&#039;:
					pinnedMessages.pin(messageId, roomId);
					break;
				case &#039;unpin&#039;:
					pinnedMessages.unpin(messageId, roomId);
					break;
			}
		});
	};

	Chats.addHotkeys = function () {
		mousetrap.bind(&#039;ctrl+up&#039;, function () {
			const activeContact = $(&#039;.chats-list .active&#039;);
			const prev = activeContact.prevAll(&#039;[data-roomid]&#039;).first();
			if (prev.length &amp;&amp; prev.attr(&#039;data-roomid&#039;)) {
				Chats.switchChat(prev.attr(&#039;data-roomid&#039;));
			}
		});
		mousetrap.bind(&#039;ctrl+down&#039;, function () {
			const activeContact = $(&#039;.chats-list .active&#039;);
			const next = activeContact.nextAll(&#039;[data-roomid]&#039;).first();
			if (next.length &amp;&amp; next.attr(&#039;data-roomid&#039;)) {
				Chats.switchChat(next.attr(&#039;data-roomid&#039;));
			}
		});
		mousetrap.bind(&#039;up&#039;, function (e) {
			const inputEl = components.get(&#039;chat/input&#039;);
			if (e.target === inputEl.get(0) &amp;&amp; !inputEl.val()) {
				// Retrieve message id from messages list
				const message = components.get(&#039;chat/messages&#039;).find(&#039;.chat-message[data-self=&quot;1&quot;]&#039;).last();
				if (!message.length) {
					return;
				}
				const lastMid = message.attr(&#039;data-mid&#039;);
				messages.prepEdit(message, lastMid, ajaxify.data.roomId);
			}
		});
	};

	Chats.addManageHandler = function (roomId, buttonEl) {
		manage.init(roomId, buttonEl);
	};

	Chats.addLeaveHandler = function (roomId, buttonEl) {
		buttonEl.on(&#039;click&#039;, function () {
			bootbox.confirm({
				size: &#039;small&#039;,
				title: &#039;[[modules:chat.leave]]&#039;,
				message: &#039;&lt;p&gt;[[modules:chat.leave-prompt]]&lt;/p&gt;&lt;p class=&quot;form-text&quot;&gt;[[modules:chat.leave-help]]&lt;/p&gt;&#039;,
				callback: function (ok) {
					if (ok) {
						api.del(`/chats/${roomId}/users/${app.user.uid}`, {}).then(() =&gt; {
							// Return user to chats page. If modal, close modal.
							const modal = buttonEl.parents(&#039;.chat-modal&#039;);
							if (modal.length) {
								chatModule.close(modal);
							} else {
								Chats.destroyAutoComplete(roomId);
								ajaxify.go(&#039;chats&#039;);
							}
						}).catch(alerts.error);
					}
				},
			});
		});
	};

	Chats.addDeleteHandler = function (roomId, buttonEl) {
		buttonEl.on(&#039;click&#039;, function () {
			bootbox.confirm({
				size: &#039;small&#039;,
				title: &#039;[[modules:chat.delete]]&#039;,
				message: &#039;&lt;p&gt;[[modules:chat.delete-prompt]]&lt;/p&gt;&#039;,
				callback: function (ok) {
					if (ok) {
						api.del(`/admin/chats/${roomId}`, {}).then(() =&gt; {
							// Return user to chats page. If modal, close modal.
							const modal = buttonEl.parents(&#039;.chat-modal&#039;);
							if (modal.length) {
								chatModule.close(modal);
							} else {
								Chats.destroyAutoComplete(roomId);
								ajaxify.go(&#039;chats&#039;);
							}
						}).catch(alerts.error);
					}
				},
			});
		});
	};

	Chats.addRenameHandler = function (roomId, buttonEl) {
		buttonEl.on(&#039;click&#039;, async function () {
			const { roomName } = await api.get(`/chats/${roomId}`);
			const html = await app.parseAndTranslate(&#039;modals/rename-room&#039;, {
				name: roomName,
			});
			const modal = bootbox.dialog({
				title: &#039;[[modules:chat.rename-room]]&#039;,
				message: html,
				onEscape: true,
				buttons: {
					save: {
						label: &#039;[[global:save]]&#039;,
						className: &#039;btn-primary&#039;,
						callback: function () {
							api.put(`/chats/${roomId}`, {
								name: modal.find(&#039;#roomName&#039;).val(),
							}).then(() =&gt; {
								modal.modal(&#039;hide&#039;);
							}).catch(alerts.error);
							return false;
						},
					},
				},
			});
		});
	};

	Chats.addSendHandlers = function (roomId, inputEl, sendEl) {
		if (!utils.isMobile()) {
			inputEl.off(&#039;keypress&#039;).on(&#039;keypress&#039;, function (e) {
				if (e.which === 13 &amp;&amp; !e.shiftKey) {
					messages.sendMessage(roomId, inputEl);
					return false;
				}
			});
		}

		sendEl.off(&#039;click&#039;).on(&#039;click&#039;, function () {
			messages.sendMessage(roomId, inputEl);
			inputEl.focus();
			return false;
		});
	};

	Chats.createAutoComplete = function (roomId, element, options = {}) {
		if (!element.length) {
			return;
		}

		const data = {
			element: element,
			strategies: [],
			options: {
				style: {
					&#039;z-index&#039;: 20000,
					flex: 0,
					top: &#039;inherit&#039;,
				},
				placement: &#039;top&#039;,
				className: `chat-autocomplete-dropdown-${roomId} dropdown-menu textcomplete-dropdown`,
				...options,
			},
		};

		$(window).trigger(&#039;chat:autocomplete:init&#039;, data);
		if (data.strategies.length) {
			const autocompleteEl = autocomplete.setup(data);
			if (roomId) {
				Chats.activeAutocomplete[roomId] = autocompleteEl;
			}
			return autocompleteEl;
		}
	};

	Chats.destroyAutoComplete = function (roomId) {
		if (Chats.activeAutocomplete[roomId]) {
			Chats.activeAutocomplete[roomId].destroy();
			delete Chats.activeAutocomplete[roomId];
		}
	};

	Chats.leave = function (el) {
		const roomId = el.attr(&#039;data-roomid&#039;);
		api.del(`/chats/${roomId}/users/${app.user.uid}`, {}).then(() =&gt; {
			if (parseInt(roomId, 10) === parseInt(ajaxify.data.roomId, 10)) {
				ajaxify.go(&#039;user/&#039; + ajaxify.data.userslug + &#039;/chats&#039;);
			} else {
				el.remove();
			}
			Chats.destroyAutoComplete(roomId);
			const modal = chatModule.getModal(roomId);
			if (modal.length) {
				chatModule.close(modal);
			}
		}).catch(alerts.error);
	};

	Chats.switchChat = function (roomId) {
		// Allow empty arg for return to chat list/close chat
		if (!roomId) {
			roomId = &#039;&#039;;
		}
		Chats.destroyAutoComplete(ajaxify.data.roomId);
		socket.emit(&#039;modules.chats.leave&#039;, ajaxify.data.roomId);
		const url = &#039;user/&#039; + ajaxify.data.userslug + &#039;/chats/&#039; + roomId + window.location.search;
		if (!self.fetch) {
			return ajaxify.go(url);
		}
		const params = new URL(document.location).searchParams;
		params.set(&#039;switch&#039;, 1);
		const dataUrl = `${config.relative_path}/api/user/${ajaxify.data.userslug}/chats/${roomId}?${params.toString()}`;
		fetch(dataUrl, { credentials: &#039;include&#039; })
			.then(async function (response) {
				if (!response.ok) {
					return console.warn(&#039;[search] Received &#039; + response.status);
				}
				const payload = await response.json();
				const html = await app.parseAndTranslate(&#039;partials/chats/message-window&#039;, payload);
				const mainWrapper = components.get(&#039;chat/main-wrapper&#039;);
				mainWrapper.html(html);
				mainWrapper.attr(&#039;data-roomid&#039;, roomId);
				chatNavWrapper = $(&#039;[component=&quot;chat/nav-wrapper&quot;]&#039;);
				html.find(&#039;.timeago&#039;).timeago();
				ajaxify.data = { ...ajaxify.data, ...payload, roomId: roomId };
				ajaxify.updateTitle(ajaxify.data.title);
				$(&#039;body&#039;).toggleClass(&#039;chat-loaded&#039;, !!roomId);
				mainWrapper.find(&#039;[data-bs-toggle=&quot;tooltip&quot;]&#039;).tooltip({ trigger: &#039;hover&#039;, container: &#039;#content&#039; });
				Chats.setActive(roomId);
				Chats.addEventListeners();
				hooks.fire(&#039;action:chat.loaded&#039;, $(&#039;.chats-full&#039;));
				messages.scrollToBottomAfterImageLoad(mainWrapper.find(&#039;[component=&quot;chat/message/content&quot;]&#039;));
				if (history.pushState) {
					history.pushState({
						url: url,
					}, null, window.location.protocol + &#039;//&#039; + window.location.host + config.relative_path + &#039;/&#039; + url);
				}
			})
			.catch(function (error) {
				console.warn(&#039;[search] &#039; + error.message);
			});
	};

	Chats.addGlobalEventListeners = function () {
		$(window).on(&#039;mousemove keypress click&#039;, function () {
			if (newMessage &amp;&amp; ajaxify.data.roomId) {
				api.del(`/chats/${ajaxify.data.roomId}/state`, {});
				newMessage = false;
			}
		});
	};

	Chats.addSocketListeners = function () {
		socket.on(&#039;event:new_notification&#039;, async function (notif) {
			const { type, roomId } = notif;
			if (ajaxify.data.template.chats &amp;&amp; app.user.userslug &amp;&amp; (type === &#039;new-chat&#039; || type === &#039;new-group-chat&#039;)) {
				const inRoom = parseInt(roomId, 10) === parseInt(ajaxify.data.roomId, 10);
				if (inRoom) {
					return;
				}
				const { rooms } = await api.get(`/chats`, { start: 0, perPage: 1 });
				const room = rooms.find(r =&gt; parseInt(r.roomId, 10) === parseInt(roomId, 10));
				if (room) {
					const roomEl = chatNavWrapper.find(`[data-roomid=&quot;${roomId}&quot;]`);
					if (roomEl.length) {
						updateTeaser(roomId, room.teaser);
					} else {
						const recentEl = components.get(&#039;chat/recent&#039;);
						const html = await app.parseAndTranslate(&#039;chats&#039;, &#039;rooms&#039;, {
							rooms: [room],
							showBottomHr: true,
						});
						recentEl.prepend(html);
					}
				}
			}
		});

		socket.on(&#039;event:chats.receive&#039;, function (data) {
			if (chatModule.isFromBlockedUser(data.fromUid)) {
				return;
			}
			if (parseInt(data.roomId, 10) === parseInt(ajaxify.data.roomId, 10)) {
				data.self = parseInt(app.user.uid, 10) === parseInt(data.fromUid, 10) ? 1 : 0;
				if (!newMessage) {
					newMessage = data.self === 0;
				}
				data.message.self = data.self;
				data.message.timestamp = Math.min(Date.now(), data.message.timestamp);
				data.message.timestampISO = utils.toISOString(data.message.timestamp);
				messages.appendChatMessage($(&#039;[component=&quot;chat/message/content&quot;]&#039;), data.message);

				updateTeaser(data.roomId, {
					content: utils.stripHTMLTags(utils.decodeHTMLEntities(data.message.content)),
					user: data.message.fromUser,
					timestampISO: data.message.timestampISO,
				});
			}
		});

		async function updateTeaser(roomId, teaser) {
			const roomEl = $(`[data-roomid=&quot;${roomId}&quot;]`);
			if (roomEl.length) {
				const html = await app.parseAndTranslate(&#039;partials/chats/room-teaser&#039;, {
					teaser: teaser,
				});
				roomEl.find(&#039;[component=&quot;chat/room/teaser&quot;]&#039;).html(html[0].outerHTML);
				roomEl.find(&#039;.timeago&#039;).timeago();
			}
		}

		socket.on(&#039;event:chats.public.unread&#039;, function (data) {
			if (
				chatModule.isFromBlockedUser(data.fromUid) ||
				chatModule.isLookingAtRoom(data.roomId) ||
				app.user.uid === parseInt(data.fromUid, 10)
			) {
				return;
			}
			Chats.markChatPageElUnread(data);
			Chats.increasePublicRoomUnreadCount(chatNavWrapper.find(&#039;[data-roomid=&#039; + data.roomId + &#039;]&#039;));
		});

		socket.on(&#039;event:user_status_change&#039;, function (data) {
			app.updateUserStatus($(&#039;.chats-list [data-uid=&quot;&#039; + data.uid + &#039;&quot;] [component=&quot;user/status&quot;]&#039;), data.status);
		});

		messages.addSocketListeners();

		socket.on(&#039;event:chats.roomRename&#039;, function (data) {
			const roomEl = components.get(&#039;chat/recent/room&#039;, data.roomId);
			if (roomEl.length) {
				const titleEl = roomEl.find(&#039;[component=&quot;chat/room/title&quot;]&#039;);
				ajaxify.data.roomName = data.newName;
				titleEl.translateText(data.newName ? data.newName : ajaxify.data.usernames);
			}
			const titleEl = $(`[component=&quot;chat/main-wrapper&quot;][data-roomid=&quot;${data.roomId}&quot;] [component=&quot;chat/header/title&quot;]`);
			if (titleEl.length) {
				titleEl.html(
					data.newName ?
						`&lt;i class=&quot;fa ${ajaxify.data.icon} text-muted&quot;&gt;&lt;/i&gt; ${data.newName}` :
						ajaxify.data.chatWithMessage
				);
			}
		});

		socket.on(&#039;event:chats.mark&#039;, ({ roomId, state }) =&gt; {
			const roomEls = $(`[component=&quot;chat/recent&quot;] [data-roomid=&quot;${roomId}&quot;], [component=&quot;chat/list&quot;] [data-roomid=&quot;${roomId}&quot;], [component=&quot;chat/public&quot;] [data-roomid=&quot;${roomId}&quot;]`);
			roomEls.each((idx, el) =&gt; {
				const roomEl = $(el);
				chatModule.markChatElUnread(roomEl, state === 1);
				if (state === 0) {
					Chats.updatePublicRoomUnreadCount(roomEl, 0);
				}
			});
		});

		socket.on(&#039;event:chats.typing&#039;, async (data) =&gt; {
			if (data.uid === app.user.uid || chatModule.isFromBlockedUser(data.uid)) {
				return;
			}
			chatModule.updateTypingUserList($(`[component=&quot;chat/main-wrapper&quot;][data-roomid=&quot;${data.roomId}&quot;]`), data);
		});
	};

	Chats.markChatPageElUnread = function (data) {
		if (!ajaxify.data.template.chats) {
			return;
		}

		const roomEl = chatNavWrapper.find(&#039;[data-roomid=&#039; + data.roomId + &#039;]&#039;);
		chatModule.markChatElUnread(roomEl, true);
	};

	Chats.increasePublicRoomUnreadCount = function (roomEl) {
		const unreadCountEl = roomEl.find(&#039;[component=&quot;chat/public/room/unread/count&quot;]&#039;);
		const newCount = (parseInt(unreadCountEl.attr(&#039;data-count&#039;), 10) || 0) + 1;
		Chats.updatePublicRoomUnreadCount(roomEl, newCount);
	};

	Chats.updatePublicRoomUnreadCount = function (roomEl, count) {
		const unreadCountEl = roomEl.find(&#039;[component=&quot;chat/public/room/unread/count&quot;]&#039;);
		const countText = count &gt; 50 ? &#039;50+&#039; : count;
		unreadCountEl.toggleClass(&#039;hidden&#039;, count &lt;= 0).text(countText).attr(&#039;data-count&#039;, count);
	};

	Chats.setActive = function (roomId) {
		chatNavWrapper.find(&#039;[data-roomid]&#039;).removeClass(&#039;active&#039;);
		if (roomId) {
			socket.emit(&#039;modules.chats.enter&#039;, roomId);
			const chatEl = chatNavWrapper.find(`[data-roomid=&quot;${roomId}&quot;]`);
			chatEl.addClass(&#039;active&#039;);
			if (chatEl.hasClass(&#039;unread&#039;)) {
				api.del(`/chats/${roomId}/state`, {});
				chatEl.removeClass(&#039;unread&#039;);
			}

			if (!utils.isMobile()) {
				$(&#039;.expanded-chat [component=&quot;chat/input&quot;]&#039;).focus();
			}
			messages.updateTextAreaHeight($(`[component=&quot;chat/messages&quot;][data-roomid=&quot;${roomId}&quot;]`));
		}

		chatNavWrapper.attr(&#039;data-loaded&#039;, roomId ? &#039;1&#039; : &#039;0&#039;);
	};

	return Chats;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
